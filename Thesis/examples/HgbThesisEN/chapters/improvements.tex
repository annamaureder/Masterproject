\chapter{Improvements}

In case of articulated objects with a skelton structure, the segmentation algorithm in its simple form fails. The main reasons are the following:
%%
\begin{itemize}
	\item By recursively subdividing $C_1$ and $C_2$ the detected sub clusters might actually count to more than one and being located apart from each other. 
	\item In case of a matching cluster being a part of a rigid part, no further operations are done with the match. The rigid part is anticipated to be generated by merging neighboring sub clusters.
	\item By further sub dividing clusters, the merging becomes more difficult, as the clusters are scattered next to each other.
	\item The detection of joints is not exact although the segmentation in the approximate rigid parts succeeds as sub clusters are good enough to fit, but still there might be better fits with less or more points.
\end{itemize}
%%
Thus, the initial approach needs to be extended, which solved the issues being mentioned.

\section{Region growing}
During the segmentation of an object in two different poses, there is the general case that the divided parts being compared do not contain the same number of points. As this state might come to undesirable matching errors, parts with the same sizes could be generated by region growing. This can be e.g. implemented by starting with the most outside point of two poses and grow regions with the same size of points which are then compared. Furthermore, the detection of multiple clusters can be treated, in case of subdividing clusters. The detected clusters are as a result treated individually.

\section{Matching error}
Another improvement is the assurance that during the ICP procedure each point only has one nearest neighbor and also considering the case, that there are not always the same amount of points in two clusters (uneven number of points). By doing so, not all points would contribute to the matching error. Furthermore, weights should be added to the points, especially points located near a joint should be treated cautiously. A cluster could be therefore further subdivided, if a minimum number of points is above the error threshold $\tau$ and not the average. 

%\section{Initial alignment of clusters}
%The initial ``Divide and Conquer'' approach is used to detect two matching sub clusters of $C_1$ and $C_2$. But unlike previous implementations, the rigid parts are not detected by a following merging step, but by region growing, until the matching error $e$ is above the specified threshold $\tau$.
%If a rigid part is detected, it is stored and the same procedures initiates with the other points of $C_1$ and $C_2$. By doing so, all rigid parts are sequentially detected from one direction to the other.

%\subsection{Error handling}
%The region growing procedure needs to terminate if points of another rigid part are added. Following, a higher matching error $e$ is detected. To guarantee successful rigid part detection this procedure premises that the regions in two comparing sub clusters grow the same way, otherwise the region growing might terminate before detecting the whole rigid part. 

\section{Segmentation of articulated objects}
The initial approach fails with articulated objects, whose parts are not simple linked as a chain, but a rigid part can have more than two linking rigid parts. An example would be the skeleton of humans and most animals. As a result, the objects are simply too complex to linearly subdivide them.
One improvement proposition is thereby the initial alignment of the object, that the largest rigid part is aligned.  A similar approach was taken during the LRP algorithm \cite{guo2016correspondence}. Then, recursively linked parts of this largest rigid part are detected (see section \ref{LRP}).

\section{Largest rigid part}
\label{LRP}

As opposed to recursively subdividing $C_1$ and $C_2$ into sub clusters, as an initial step the largest rigid part (LRP) is detected. From there, all other linked parts can be detected by region growing and reapplying the algorithm.
The algorithm was applied on 3D point clouds by \ref{LRP}.

\subsection{Basic functionality}
\label{functionalityLRP}
As an initial step, the LRP algorithm  attempts to detect the most reliable correspondences between $C_1$ and $C_2$. For that, local descriptors are computed. The requirement for a sparse correspondence between two cluster points $\boldsymbol{p}_i(x,y)$ and $\boldsymbol{p}_j(x,y)$ is that they are \textit{reciprocal}, which means that the euclidean distance $d(\boldsymbol{p}_i,\boldsymbol{p}_j)$ between them is the smallest in both directions. Some of the sparse correspondences are assumed to be wrong. Therefore, by applying RANSAC to the point correspondences, a single rigid transformation is aimed for to detect the so-called ``largest rigid part'' (LRP), which is supported by the largest corresponding point cluster between $C_1$ and $C_2$. In case of a human, this would be the torso. Subsequently, all linked rigid parts to the LRP are detected by recursively applying the algorithm on grown clusters from the current LRP.

\subsection{Implementation steps}

In order to re-implement the algorithm in 2D, modifications had to be accomplished. The most crucial part of the whole algorithm is the initial alignment of $C_1$ and $C_2$ in order to detect the actual largest rigid part of the articulated object. This step is of particular importance, as the subsequent detection of further rigid parts proceeds from there. As no local As no local descriptors are computed, the alignment depends on the ICP (see subsection \ref{correspondences}) General steps that are conducted are the following: 

\begin{enumerate}
	\item The PCA is employed on the input clusters $C_1$ and $C_2$ to coincide their orientations. 
	\item The ICP is conducted as a first guess to find a transformation $T_i$ for all cluster points from $C_1$ that result in the highest number of reciprocal corresponding points $n$ in $C_2$, given the threshold $\tau$.
	\item The RANSAC approach is applied on those corresponding points to detect a $T_j$ that rejects wrong point correspondences. Clusters are detected from all corresponding points by applying region growing.
	\item The LRP is assigned to the resulting biggest point cluster.
	\item Proceeding with the LRP, unmatched clusters to $C_1$ and $C_2$ are seeked by region growing from the LRP. The algorithm is then reapplied on those clusters until all rigid parts have been discovered.
\end{enumerate}

\subsection{Detection of sparse correspondences}
\label{correspondences}

Sparse correspondences of two input clusters $C_i$ and $C_j$ are achieved by applying the Iterative closest point algorithm. Thereby, corresponding points of $C_i$ and $C_j$ are only considered, if they are \textit{reciprocal} (see subsection \ref{functionalityLRP}). Furthermore, the euclidean distance between two cluster points $d(\boldsymbol{p}_i,\boldsymbol{p}_j)$ must be below a predefined threshold $\tau$. As a consequence, points being located far away from each other do not contribute to the alignment of $C_i$ and $C_j$ and are not stored as correspondence. Those are assumed to be small rigid parts with different transformations.

\subsection{Detection of the LRP}
\label{detectionLRP}
The dense point correspondences from the previous computation step (see subsection \ref{correspondences}) may contain several errors. Therefore, RANSAC is applied as a next step to detect a single rigid transformation $T$ that leads to the biggest overlapping point cluster of $C_i$ and $C_j$. The clusters are thereby grown from all corresponding points with an euclidean distance $d(\boldsymbol{p}_i,\boldsymbol{p}_j)$ again below a predefined threshold $\tau$. The procedure is applied both on $C_i$ and $C_j$ which results in two rigid parts as output.

\subsection{Cluster detection}
\label{cluster}
After successfully detecting the largest rigid part of the input clusters $C_i$ and $C_j$ all unclustered points are outlined by taking all points of $C_1$ and $C_2$ apart from all earlier detected largest rigid parts. Potential linked rigid parts are grown from the last detected largest rigid part as seed taking all unclustered points as input. In case of detecting more than one cluster, which might be the case of region growing from the torso, it must be verified which clusters of $C_1$ and $C_2$ match and taken again as input for the whole algorithm. Thereby, the actual seed the clusters are grown from are stored as joints. The clusters with the closest joints are then selected to match....



%TODO: write push/pop algoirthm to recursively detect linked parts
%TODO: PICTURES





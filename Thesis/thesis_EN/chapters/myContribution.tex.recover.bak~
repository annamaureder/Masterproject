\chapter{My contribution}
\label{cha:MyContribution}

This chapter focuses on the implementation of a new segmentation approach by taking the existing methods as reference (see chapter \ref{cha:relatedWork}). The goal is to segment an articulated mesh \textit{M} into its unknown number \textit{n} of rigid parts \textit{P = \{{part\textsubscript{0}, ...,  part\textsubscript{n}\}}}, which is done by non-rigid registration of the points clouds \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} of an object in two different poses . Basically, a divide and conquer approach (see section \ref{divideAndConquer}) is implemented to reduce the computation steps of the correlated correspondence algorithm \cite{Anguelov04}. Furthermore, the LRP approach \cite{correspondence} is employed as an initial registration step to align the two poses of the object. 

\section{Assumptions}

The input mesh \textit{M} is assumed to solely consist of rigid parts that can not be deformed or stretched (e.g. rigid parts of a human). Those parts are linked by joints and no matter what kind of pose is adopted by the articulated object, the geodesic distances bestween mesh points always stay the same (see Figure SKIZZE). As a result the object can be described as a skeleton structure, where parts are always linked the same. Thereby, it is taken advantage of the knowledge that the points located on one rigid part have the same transformation \textit{T = \{T\textsubscript{0}, ...,  T\textsubscript{n}\}}.

\section{Challenges/restrictions}

There are many challenges regarding the non-rigid registration of point clouds in 2D, as well as in 3D. First off, the input data can be noisy by means of points not belonging to the object. Furthermore, the approach is computationally expensive and time-consuming, as the corresponding body parts of two meshes need to be detected iteratively. Additionally, the inevitable difficulty of finding the global optimum, related to ambiguous body parts, has to be overcome.

\section{Divide and conquer approach}
\label{divideAndConquer}

The point clouds \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} are iteratively subdivided into point clusters \textit{C = \{{cluster\textsubscript{0}, ...,  cluster\textsubscript{m}\}}} by a divider \textit{d}. In each iteration step two related clusters are matched by applying the ICP (iterative closest point) resulting in a matching error \textit{e}. In case of \textit{e} < \textit{e\textsubscript{threshold}}, two clusters are assumed to match. As it might be the case to have detected only a piece of a rigid part, the divider is slided to enlarge the clusters. This is done until the matching error gets higher. The matching clusters are assigned to a rigid part \textit{part\textsubscript{i}}. In case of \textit{e} > \textit{e\textsubscript{treshold}} the algorithm is applied recursively and the clusters are again subdivided into further clusters.

\subsection{Basic functionality for an articulated object with two parts}

Assuming that the object is only composed of two rigid parts, the approach would work the following:

 The algorithm starts with two sets of point clouds \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} of the same object in different poses (\ref{fig:dc_original_p2}). \textit{S\textsubscript{0}} is used as a \textit{template} to be registered with \textit{D\textsubscript{0}}. The goal is to find a part assignment \textit{P = \{{part\textsubscript{0}, part\textsubscript{1}\}}} and transformation \textit{T = \{T\textsubscript{0}, T\textsubscript{1}\}} for all points of the \textit{template} that alligns them with all points of \textit{D\textsubscript{0}}. To iteratively find corresponding parts and transformations, \textit{S\textsubscript{0}} as well as \textit{D\textsubscript{0}} are divided into clusters \textit{C = \{{cluster\textsubscript{0}, cluster\textsubscript{1}\}}} . The dividers \textit{d\textsubscript{S}} and \textit{d\textsubscript{D}} are initially defined with the secondary axis \textit{s\textsubscript{S}} and \textit{s\textsubscript{D}} (see Figure \ref{fig:dc_axes_2p}). The resulting clusters are matched together with the ICP. Depending on the matching errors \textit{e\textsubscript{left}} and \textit{e\textsubscript{right}}, the dividers are slided alongside the principal axis \textit{p\textsubscript{S}} and \textit{p\textsubscript{D}} of the objects to grow/shrink the clusters. The algorithm terminates if the total error \textit{e\textsubscript{total} = e\textsubscript{right} + e\textsubscript{left}} doesn't get any smaller and the part assignments are accomplished (see Figure \ref{fig:dc_results_2p}).
 
  \begin{figure}
  	\centering
  	\includegraphics[width=0.7\linewidth]{illustration_original}
  	\caption{Taking a mesh \textit{M} in two different poses \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} as input.}
  	\label{fig:dc_original_p2}
  \end{figure}
 
 \begin{figure}
 	\centering
 	\includegraphics[width=0.7\linewidth]{illustration_axes}
 	\caption{Dividing \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} into clusters by the divider \textit{d} to match them with ICP.}
 	\label{fig:dc_axes_2p}
 \end{figure}

 \begin{figure}
 	\centering
 	\includegraphics[width=0.7\linewidth]{illustration_results}
 	\caption{Assigning of the rigid parts \textit{P =(part\textsubscript{0}, part\textsubscript{1})} after termination of segmentation process.}
 	\label{fig:dc_results_2p}
 \end{figure}
 
 \subsection{Implementation Steps}
 
 \begin{enumerate}
 	\item The centroids \textit{c\textsubscript{S}} and \textit{c\textsubscript{D}} of \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} are computed.
 	
 	\item The principal axis \textit{p\textsubscript{S}} and \textit{p\textsubscript{D}}  are computed through \textit{c\textsubscript{S}} and \textit{c\textsubscript{D}} in order to orient the point clouds horizonally around their centroids.
 	
 	\item The secondary axis \textit{s\textsubscript{S}} and \textit{s\textsubscript{D}} perpendicular to \textit{p\textsubscript{S}} and \textit{p\textsubscript{D}} through \textit{c\textsubscript{S}} and \textit{c\textsubscript{D}} are computed.
 	
 	\item The dividers \textit{d\textsubscript{S}} and \textit{d\textsubscript{T}} to segment \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} into its assumed two rigid parts are initialized with the secondary axis \textit{s\textsubscript{S}} and \textit{s\textsubscript{D}}.
 	
 	\item The points \textit{P\textsubscript{0...N}} of \textit{S\textsubscript{0}}  are either allocated to \textit{S\textsubscript{left}} or \textit{S\textsubscript{right}} depending on its position to \textit{d\textsubscript{S}}. The same procedure is done with all points of \textit{D\textsubscript{0}}.
 	
 	\item ICP is computed between the rigid parts \textit{S\textsubscript{left}} and \textit{D\textsubscript{left}} as well as \textit{S\textsubscript{right}} and \textit{D\textsubscript{right}}.
 	
 	\item An error distance \textit{e\textsubscript{left}} and \textit{e\textsubscript{right}} is obtained. The part with the most error per point is assumed to be not rigid which gives back an indicator where to divide \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}}.
 	
 	\item The dividers \textit{d\textsubscript{S}} and \textit{d\textsubscript{D}} are shifted to the direction of the highest error. To be continued from step 5 until the total error \textit{e\textsubscript{total}} doesn't get smaller.
 \end{enumerate}

\section{Segmentation of unknown number of rigid parts}

In case of having an unknown number of rigid parts \textit{n}, the algorithm above has to be applied recursively in order to find all part assignments \textit{P = \{{part\textsubscript{0} ... part\textsubscript{n}\}}}. \textit{S\textsubscript{0}} and \textit{D\textsubscript{0}} are thereby initially divided into two assumed rigid parts by the dividers \textit{d\textsubscript{S}} and \textit{d\textsubscript{D}} initialized with \textit{s\textsubscript{S}} and \textit{s\textsubscript{D}}. The goal is now to find single parts by sliding another divider over \textit{S\textsubscript{left}} and \textit{D\textsubscript{left}} as well as \textit{S\textsubscript{right}} and \textit{D\textsubscript{right}} until the error \textit{e} for one part doesn't get any smaller. The total error \textit{e\textsubscript{total}} is not used any more as dividing one part into two doesn't ensure that they are both rigid. After assigning points to a Part \textit{P} the geodesic distance between points of rigid parts can be used to find further connecting parts. By taking the dividers as joints and taking into account that rigid parts are located between the same joints, rigid parts in the middle of the object can be easier detected.


\subsection{Removing outliers}

As a first step the outliers of the two point clouds S0 and D0 are removed. This is done, by finding clusters and just keeping the biggest one, assuming it is the main object

\subsection{Subdividing into matching clusters}

As a next step, the two meshes are recursively subdivided into sub clusters. This is realised in form of a binary tree. The cluster0 is initially divided into a left and right cluster if the matching between cluster0 of S0 and D0 does not work. A new cluster can again be subdivided, if not matching into left and right. By doing the dividing as a depth-first approach of a tree, the whole object is subdivided from the left to the right. If no subdividing is done anymore (as two clusters of two objects match), those clusters are stored as matching cluster. By recursively dividing the objects from one side to another, the neighboring clusters in the list are also neighboring clusters of the object (see Figure XXX).

\subsubsection{Declaring the matching condition}

By applying the ICP and the nearest neighbor approach, a certain matching error is computed between $P =  $\left{p_0,....p_m}\right$, as points usually don't match perfectly. To declare when an object is matching, it is important to find the right maximum matching error $\tau$. If it is too high, two clusters are not likely to be matched easy, as a result the clusters will be further subdivided which results in a higher result of clusters. If the value is too low, clusters are more likely to be matched and they are probably not subdivided enough. The matching threshold is compared to error per point 
%
\begin{equation}
e_{pp} = \frac{\sum_{i=0}^{m}\| p_i - q_i\|^2}{| P |}
\end{equation}
%

which is the average error of a point contributing to the total error. By not using the total error, region growing is enabled as the error of clusters is then independent of the amount of points.

\subsection{Merging neighboring clusters to rigid parts}

As a next step, neighboring clusters from the matchedList are iteratively merged and checked for another match. This is done to reduce the found clusters to the rigid parts of the object.
Again, the mergin of one cluster is done until no further merge for neighboring parts can be done. Subsequently, the cluster is assumed to be a rigid part and saved in a new list. The resulting rigid parts in the list are again neighboring. 


\subsection{Joint/skeleton estimation}

\subsection{Implementation}

using of a binary tree to recursively segment clusters into smaller clusters, until they match. To be continued until all leaves of the tree can be matched with other clusters.

\subsection{Results}

Results from easy examples. Not working for human, as by dividing of one cluster, breaking down into single clusters (see Figure X). Another approach, e.g. using LRP as an initial alignment to then recursively segment the clusters linked to the LRP. Clusters not matching, as they don't have the same number of points, each point can only have one neighboring point. Or dividing clusters that they all have the same amount of points

\section{LRP as initial alignment}

Instead of cutting the object initially in half, as an initial step the largest rigid part is found and recursively from there all other linked parts can be detected.

\subsection{Overview}
As an initial step, the LRP algorithm tries to find the most reliable correspondences, the so-called largest rigid part (LRP), subsequently all other parts are detected that are linked to the LRP. The initial alignment stage tries to find sparse correspondences between two point clouds by applying a single rigid transformation to detect the largest subsets of points in two point clouds. Starting from the LRP all other parts are detected recursively.

\subsection{Algorithm} 

\subsubsection{Finding the LRP}

The algorithm also takes two point clouds \textit{S\textsubscript{0}} and \textit{T\textsubscript{0}} of the same object in different configurations as input.
The goal is to find a single rigid transformation \textit{T\textsubscript{init}} for all points of \textit{S\textsubscript{0}} to get potential corresponding points \textit{C\textsubscript{0} = \{(s\textsubscript{i}, t\textsubscript{j})\}} in \textit{T\textsubscript{0}}. For that, local descriptors of \textit{S\textsubscript{0}} and \textit{T\textsubscript{0}} are computed. The requirement for a sparse correspondance between two points \textit{s\textsubscript{i}} and \textit{t\textsubscript{j}}  is that they are \textit{reciprocal}, which means that the Euclidean distance \textit{d(s\textsubscript{i}, t\textsubscript{j})} between them is the smallest in both directions. Some of the sparse correspondances are asumed to be wrong. Therefore, RANSAC is used on the sparse correspondances \textit{C\textsubscript{0}} to estimate a rigid alignment that is supported by the largest number of points \textit{n} from \textit{S\textsubscript{0}} and \textit{T\textsubscript{0}}. To assign the LRP in \textit{S\textsubscript{0}} and \textit{T\textsubscript{0}}, the biggest point clusters \textit{C\textsubscript{s}} and \textit{C\textsubscript{t}} of the overlapping area \textit{G\textsubscript{s} = \{C\textsubscript{1}, ... , C\textsubscript{n}\} } and \textit{G\textsubscript{t} = \{C\textsubscript{1}, ... , C\textsubscript{n}\} } are detected. 


\subsubsection{Part discovery}

The remaining clusters from \textit{S\textsubscript{0}} and \textit{T\textsubscript{0}} that have not been registered yet are matched recursively by starting with clusters connected to already matched parts. First, all matched parts are excluded from the input point clouds  \textit{G\textsubscript{s(l+1)}} = \textit{S\textsubscript{0}} - \textit{C\textsubscript{sl}} and \textit{G\textsubscript{t(l+1)}} = \textit{T\textsubscript{0}} - \textit{C\textsubscript{tl}} defining \textit{l} as the number of already matched parts \{1, ..., n\}, \textit{C\textsubscript{sl}}. For that clusters are formed, using region taking into account that they are attached to already registered parts. The algorithm explained is applied until all body parts have been discovered.

\subsection{Steps}

\begin{enumerate}
	\item The centroids \textit{c\textsubscript{s}} and \textit{c\textsubscript{t}} of \textit{S\textsubscript{0}} and \textit{T\textsubscript{0}} are computed.
	
	\item The principal axis \textit{p\textsubscript{s}} and \textit{p\textsubscript{t}}  are computed through \textit{c\textsubscript{s}} and \textit{c\textsubscript{t}} in order to horizontally orient the objects around their centroids.
	
	\item The ICP is conducted as a first guess to find a transformation \textit{T\textsubscript{init}} for all points from \textit{S\textsubscript{0}} that results in the highest number of corresponding points \textit{n} in \textit{T\textsubscript{0}}, given the threshold \textit{T}.
	
	\item \textit{C\textsubscript{0}} contains the corresponding points from S\textsubscript{0} and T\textsubscript{0}, resulting from \textit{T\textsubscript{init}(S\textsubscript{0})}.
	
	\item The RANSAC approach is applied on \textit{C\textsubscript{0}} to find a  \textit{T\textsubscript{f}} that results in the highest number of corresponding points \textit{n} between \textit{T\textsubscript{f}(S\textsubscript{0})} and \textit{T\textsubscript{0}}.
	
	\item The LRP is assigned to \textit{C\textsubscript{s}} and \textit{C\textsubscript{t}} from the resulting point clusters \textit{G\textsubscript{s}} and \textit{G\textsubscript{t}}.
	
	\item Starting from parts that are connected to the LRP, corresponding points \textit{C\textsubscript{i}} for unmatched points from \textit{S\textsubscript{0}} and \textit{T\textsubscript{0}} are seeked. The clusters are given as a input from Step 5. 
		
\end{enumerate}

\section{Other approaches}

\section{Points-to-Ellipse fitting}

\subsection{Algorithm}

This algorithm only requires one point cloud containing \textit{m} points \{\textit{pt\textsubscript{0}, ..., pt\textsubscript{m}}\}. The basic idea is to segment the non-rigid object  \textit{S\textsubscript{0}} into its rigid parts \textit{part\textsubscript{1}} and {part\textsubscript{2}} by fitting ellipses to its rigid parts. 
\textit{S\textsubscript{0}} is divided perpendicular to its principal axis \textit{p\textsubscript{0}} into two assumed rigid parts \textit{S\textsubscript{left}} and \textit{S\textsubscript{right}}, initially defining the divider \textit{d} with the secondary axis \textit{s\textsubscript{0}}. The points of \textit{S\textsubscript{left}} and \textit{S\textsubscript{right}} are verified to 
form an ellipse by using its formular

\begin{equation}
\dfrac{x^2}{r_1^2} + \dfrac{y^2}{r_2^2} = 1
\end{equation}

Assuming to verify \textit{S\textsubscript{left}} forming an ellipse, \textit{r\textsubscript{1}} is half the length of the principal axis \textit{p\textsubscript{left}} of \textit{S\textsubscript{left}} through its centroid \textit{c\textsubscript{left}}. Furthermore, \textit{r\textsubscript{2}} is half the length of the secondary axis {s\textsubscript{left}} of \textit{S\textsubscript{left}}. Thereby, the centroid \textit{c\textsubscript{left}} needs to be located in the origin (0,0). 
Now, to check whether a point \textit{pt\textsubscript{i}} of \textit{S\textsubscript{left}} is located on the ellipse, the formular is remodeled and its x values is applied. 

\begin{equation}
(1 -  \dfrac{x^2}{r_1^2}) \cdot {r_2^2} = y^2
\end{equation}

The resulting y-value of the ellipse is compared to the points actual y-value. Given a certain threshold $\tau$ a point either accounts to the number of total points lying on the ellipse \textit{n}, or not.

\begin{equation}
n = \sum_{i=0}^{m}\begin{cases}1 \quad if \quad \|pt_i.y^2 - y^2 \| < \tau \\ 0 \quad otherwise\end{cases}
\end{equation}

The algorithm is repeated by sliding \textit{d} in the direction of the highest error \textit{e}. To be continued until the total error \textit{e\textsubscript{total} = e\textsubscript{left} + \textsubscript{right}} reaches its minimum.

\subsection{Steps}

\begin{enumerate}
	\item The centroid \textit{c\textsubscript{0}}  of \textit{S\textsubscript{0}} is computed.
	
	\item The principal axis \textit{p\textsubscript{0}} is computed through \textit{c\textsubscript{0}} and \textit{S\textsubscript{0}} horizontally oriented. 
	
	\item The secondary axis \textit{s\textsubscript{0}}  perpendicular to \textit{p\textsubscript{0}} through \textit{c\textsubscript{0}} is computed.
	
	\item The divider \textit{d} is initialized with the secondary axis \textit{s\textsubscript{0}} to segment \textit{S\textsubscript{0}} into two assumed rigid parts .
	
	\item The points of \textit{S\textsubscript{0}} are either allocated to \textit{S\textsubscript{left}} or \textit{S\textsubscript{right}} depending on its position to \textit{d\textsubscript{0}}.
	
	\item The ellipse formular is applied on \textit{S\textsubscript{left}} and \textit{S\textsubscript{right}}.
	
	\item An error \textit{e\textsubscript{left}} and \textit{e\textsubscript{right}} is obtained implying how many points of \textit{S\textsubscript{left}} and \textit{S\textsubscript{right}} form an ellipse. 
	
	\item The divider \textit{d} is shifted to the direction of the highest error. To be continued from step 5 until the total error \textit{e\textsubscript{total}} doesn't get smaller. 
\end{enumerate}

\subsection{Results}

\subsection{Reusing detected shapes}

After termination of the algorithm, one point cloud can be segmented into its rigid parts P \{part\textsubscript{1}, ..., part\textsubscript{n}\}. Their variables like the ellipses' centroid \textit{c\textsubscript{i}} and radii \textit{r\textsubscript{1}}, \textit{r\textsubscript{2}} can be used to segment similar point clouds in different configurations. As the shapes to be matched are already known, e.g. how they are linked, finding the position to be segmented is a lot easier.



\section{General Results}

\section{Improvements}

\section{Future work}

The approaches implemented in 2D are then implemented in 3D using the PCL. 

